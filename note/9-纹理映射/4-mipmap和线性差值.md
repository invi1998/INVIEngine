## Mipmap

Mipmap是一种纹理预处理技术，用于在不同的距离和角度下显示正确的纹理贴图。它通过生成多张不同分辨率的纹理贴图来实现。这些纹理贴图按照从大到小的顺序排列，并且每个贴图都是前一个贴图的1/4大小。

Mipmap技术可以提高渲染性能和图像质量。当纹理贴图被缩小时，它会失去细节和清晰度，因为同一颜色的像素被合并成一个像素。使用Mipmap技术可以减轻这种模糊效果，因为在小纹理上使用更高分辨率的纹理贴图，使缩小的图片看起来更加平滑、清晰。

当使用Mipmap技术时，纹理贴图被分解成一系列不同的尺寸级别，从原始分辨率开始，逐渐递减，直到最低分辨率（通常是1x1）。当渲染三维模型时，程序会自动选择与物体表面距离和角度最相似的mipmap级别。如果要放大纹理贴图，则只需要使用更高分辨率的mipmaps即可。

Mipmap技术可以提高渲染性能和图像质量，并且非常适用于离观察者非常远或者非常近的情况。

## Mipmap占内存多少（原图的1/3）

Mipmap是由多个分辨率不同的纹理贴图组成的，每个贴图尺寸比前一个小1/2，因此需要占用一定的内存空间。具体来说，对于一个包含N个Mipmap级别的纹理，它所占用的内存空间可以计算为：

total_size = w * h * bits_per_pixel * (1 + 1/4 + 1/16 + ... + (1/2)^N)

其中，w和h分别表示纹理图像的宽度和高度，bits_per_pixel表示每个像素使用的位数。

以一个24位色深的1024x1024像素的纹理为例，假设它有10层Mipmap，那么根据上述公式，该纹理所占用的总内存空间为：

total_size = 1024 * 1024 * 24 / 8 * (1 + 1/4 + 1/16 + ... + (1/2)^10) ≈ 3.6MB

也就是说，如果一个Mipmap纹理有10层，它最大可能会占用3.6MB的内存空间。但实际上，在使用Mipmap时，并不会加载所有级别的纹理贴图，而是根据当前需要渲染的物体选择适当的级别，从而避免浪费内存资源。

需要注意的是，不同的纹理格式和压缩算法会影响Mipmap所占用的内存大小。例如，使用压缩格式（如DXT压缩）可以显著减小纹理占用的内存，但同时也会影响图像的质量和细节。因此，在实际应用中，需要考虑到性能、质量和内存等方面的平衡。



## 纹理的放大和缩小

纹理的放大和缩小是指将纹理图像映射到三维模型表面时，可能需要将其尺寸进行调整。具体来说，当纹理要映射到一个比其原始大小更大的表面（如一个很大的墙壁），就需要将其放大；而当纹理要映射到比其原始大小更小的表面（如一个小的水杯），就需要将其缩小。

放大会导致像素变得更加稀疏，从而使图像失去清晰度；缩小则会导致像素密度增加，从而过多细节冗余，使得图片失真。

为了应对这两种情况，可以使用以下方法：

1. 放大：在进行放大操作时，如果只是简单地将原始纹理图像进行线性插值，则会导致失真和锯齿状边缘。为了避免这种情况，通常会使用一些插值算法，如双线性插值、三线性插值、基于曲线拟合的插值等。这些算法可以根据相邻像素的颜色和位置信息计算出新像素的颜色，从而在一定程度上保留图像的质量和细节。

2. 缩小：在进行缩小操作时，如果直接丢弃某些像素，则会导致失真和模糊。为了避免这种情况，通常会先对原始纹理图像进行预处理，如滤波、抖动、mipmap等。其中最常用的是Mipmap技术，它是通过预先生成多个不同分辨率的图像副本，然后根据需要选择适当的副本，从而实现不同程度的缩小效果。Mipmap可以保留纹理的细节和质量，并提高渲染性能。

3. 

## 三线性插值

三线性插值是纹理过滤算法中的一种，它可以在放大和缩小纹理时提高渲染效果。该算法通过使用多个不同分辨率的纹理图像进行插值来实现。

具体地说，在进行三线性插值时，我们通常会在最近的两个mipmap级别之间进行线性插值，然后再对这些插值结果进行插值，从而获得最终的纹理颜色值。该算法涉及到以下步骤：

1. 根据物体距离或角度选择相应的Mipmap级别；
2. 计算出物体表面上每个像素在当前Mipmap级别下的大小；
3. 在最近的两个Mipmap级别之间进行线性插值，获得两个插值结果；
4. 在两个插值结果之间进行线性插值，获得最终的纹理颜色值；

由于三线性插值采用了多个不同分辨率的纹理贴图进行插值，因此可以有效地减少纹理失真和锯齿状边缘。当缩小大型纹理并将其映射到一个小的表面时，三线性插值可以减轻过渡效应，使得图像更加平滑和连续。

三线性插值是纹理过滤算法中一种常用的技术，可以在放大和缩小纹理时提高渲染效果，并减少纹理失真和锯齿状边缘。



## 当纹理缩小后，如何才能求得正确的mipmap层级

当纹理被缩小时，正确选择Mipmap级别是非常重要的，否则可能导致失真和模糊图像。为了找到正确的Mipmap级别，我们需要知道当前渲染纹理的大小与原始纹理的比例因子（即缩放因子）。

通常情况下，可以使用以下公式来计算当前纹理应该采用哪个Mipmap级别：

lod = log2(scale)
$$
lod = log_2{Scale}
\\ \\
Scale = max\left(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dx})^2}, \sqrt{(\frac{du}{dy})^2 + (\frac{du}{dy})^2}\right)
$$


其中，lod表示Mipmap级别，scale是当前纹理的大小与原始纹理的比例因子。该公式的基本思想是将比例因子转换为对数，然后向下取整得到最接近的Mipmap级别。

例如，如果当前纹理的大小为原始纹理的1/4，那么缩放因子就为0.25，此时可以使用上述公式计算出Mipmap级别为2。这意味着我们需要使用第二层Mipmap贴图进行渲染。

在一些实际应用中，当处理极小的纹理时，为了获得更好的效果，有时候会添加一些额外的Mipmap级别。此时，可以在计算公式中添加一个偏移量值来调整Mipmap级别，从而获得更精确的结果。



## 各项异性过滤

各向异性过滤（Anisotropic filtering，AF）是计算机图形学中一种用于提高纹理渲染质量的技术。该技术主要解决了常规纹理过滤技术中出现的失真、模糊和锯齿等问题。

在常规纹理过滤中，一个像素只能从最邻近的 Mipmap 级别中选择一个颜色进行采样。这意味着在倾斜或斜视的情况下，会发生大量的失真和锯齿。而各向异性过滤允许每个像素沿多个方向采样，以更准确地确定需要采样的纹理单元。

具体来说，各向异性过滤可以分为两个步骤：取样方向选择和纹理坐标计算。在取样方向选择阶段，通过使用卷积核函数，可以根据图像中相邻像素之间的角度和距离，计算出采样方向。然后，在纹理坐标计算阶段，使用所选的采样方向，计算出与各向异性比相关的纹理坐标，以获得最终的纹理颜色值。

各向异性过滤可以提高渲染质量，但也需要更多的计算资源。因此，当开启各向异性过滤时，需要权衡图形质量和性能需求，并考虑适当的优化策略，如降低采样率、使用Mipmap、硬件加速等。

各向异性过滤是一种用于提高纹理渲染质量的技术，它通过使用卷积核函数计算采样方向，并计算对应的纹理坐标，从而减少失真、模糊和锯齿等问题。



## 各项异性占内存多少（原图的3倍）

![image-20230922151727435](.\image-20230922151727435.png)

各向异性过滤（Anisotropic Filtering）是一种用于提高纹理渲染质量的技术，它可以消除常规纹理过滤中的失真和锯齿状边缘问题。与Mipmap不同，各向异性过滤不需要产生额外的纹理贴图，因此它所占用的内存空间相对较小。

各向异性过滤通常是由显卡硬件实现，因此不同硬件实现的内存消耗也会有所不同。另外，各向异性过滤的内存开销还取决于具体的使用情况和参数设置。

一般来说，各向异性过滤所需的内存大小主要有两个方面：卷积核函数和纹理坐标计算。卷积核函数通常是一个正方形的2D数组，大小通常为4x4或8x8。在纹理坐标计算中，需要存储每个像素沿多个方向的采样坐标。这些坐标通常需要使用浮点型数据类型来表示，并且需要根据纹理的大小和具体情况进行适当的优化。

总之，各向异性过滤所占用的内存空间相对较少，其内存消耗主要取决于硬件支持和具体实现。在实际应用中，需要根据场景、硬件性能和图像质量等因素进行权衡和调整。