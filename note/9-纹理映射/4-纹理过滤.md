## Mipmap

Mipmap是一种纹理预处理技术，用于在不同的距离和角度下显示正确的纹理贴图。它通过生成多张不同分辨率的纹理贴图来实现。这些纹理贴图按照从大到小的顺序排列，并且每个贴图都是前一个贴图的1/4大小。

Mipmap技术可以提高渲染性能和图像质量。当纹理贴图被缩小时，它会失去细节和清晰度，因为同一颜色的像素被合并成一个像素。使用Mipmap技术可以减轻这种模糊效果，因为在小纹理上使用更高分辨率的纹理贴图，使缩小的图片看起来更加平滑、清晰。

当使用Mipmap技术时，纹理贴图被分解成一系列不同的尺寸级别，从原始分辨率开始，逐渐递减，直到最低分辨率（通常是1x1）。当渲染三维模型时，程序会自动选择与物体表面距离和角度最相似的mipmap级别。如果要放大纹理贴图，则只需要使用更高分辨率的mipmaps即可。

Mipmap技术可以提高渲染性能和图像质量，并且非常适用于离观察者非常远或者非常近的情况。

## Mipmap占内存多少（原图的1/3）

Mipmap是由多个分辨率不同的纹理贴图组成的，每个贴图尺寸比前一个小1/2，因此需要占用一定的内存空间。具体来说，对于一个包含N个Mipmap级别的纹理，它所占用的内存空间可以计算为：

total_size = w * h * bits_per_pixel * (1 + 1/4 + 1/16 + ... + (1/2)^N)

其中，w和h分别表示纹理图像的宽度和高度，bits_per_pixel表示每个像素使用的位数。

以一个24位色深的1024x1024像素的纹理为例，假设它有10层Mipmap，那么根据上述公式，该纹理所占用的总内存空间为：

total_size = 1024 * 1024 * 24 / 8 * (1 + 1/4 + 1/16 + ... + (1/2)^10) ≈ 3.6MB

也就是说，如果一个Mipmap纹理有10层，它最大可能会占用3.6MB的内存空间。但实际上，在使用Mipmap时，并不会加载所有级别的纹理贴图，而是根据当前需要渲染的物体选择适当的级别，从而避免浪费内存资源。

需要注意的是，不同的纹理格式和压缩算法会影响Mipmap所占用的内存大小。例如，使用压缩格式（如DXT压缩）可以显著减小纹理占用的内存，但同时也会影响图像的质量和细节。因此，在实际应用中，需要考虑到性能、质量和内存等方面的平衡。



## 纹理的放大和缩小

纹理的放大和缩小是指将纹理图像映射到三维模型表面时，可能需要将其尺寸进行调整。具体来说，当纹理要映射到一个比其原始大小更大的表面（如一个很大的墙壁），就需要将其放大；而当纹理要映射到比其原始大小更小的表面（如一个小的水杯），就需要将其缩小。

放大会导致像素变得更加稀疏，从而使图像失去清晰度；缩小则会导致像素密度增加，从而过多细节冗余，使得图片失真。

为了应对这两种情况，可以使用以下方法：

1. 放大：在进行放大操作时，如果只是简单地将原始纹理图像进行线性插值，则会导致失真和锯齿状边缘。为了避免这种情况，通常会使用一些插值算法，如双线性插值、三线性插值、基于曲线拟合的插值等。这些算法可以根据相邻像素的颜色和位置信息计算出新像素的颜色，从而在一定程度上保留图像的质量和细节。

2. 缩小：在进行缩小操作时，如果直接丢弃某些像素，则会导致失真和模糊。为了避免这种情况，通常会先对原始纹理图像进行预处理，如滤波、抖动、mipmap等。其中最常用的是Mipmap技术，它是通过预先生成多个不同分辨率的图像副本，然后根据需要选择适当的副本，从而实现不同程度的缩小效果。Mipmap可以保留纹理的细节和质量，并提高渲染性能。

3. 

## 三线性插值

三线性插值是纹理过滤算法中的一种，它可以在放大和缩小纹理时提高渲染效果。该算法通过使用多个不同分辨率的纹理图像进行插值来实现。

具体地说，在进行三线性插值时，我们通常会在最近的两个mipmap级别之间进行线性插值，然后再对这些插值结果进行插值，从而获得最终的纹理颜色值。该算法涉及到以下步骤：

1. 根据物体距离或角度选择相应的Mipmap级别；
2. 计算出物体表面上每个像素在当前Mipmap级别下的大小；
3. 在最近的两个Mipmap级别之间进行线性插值，获得两个插值结果；
4. 在两个插值结果之间进行线性插值，获得最终的纹理颜色值；

由于三线性插值采用了多个不同分辨率的纹理贴图进行插值，因此可以有效地减少纹理失真和锯齿状边缘。当缩小大型纹理并将其映射到一个小的表面时，三线性插值可以减轻过渡效应，使得图像更加平滑和连续。

三线性插值是纹理过滤算法中一种常用的技术，可以在放大和缩小纹理时提高渲染效果，并减少纹理失真和锯齿状边缘。



## 当纹理缩小后，如何才能求得正确的mipmap层级

当纹理被缩小时，正确选择Mipmap级别是非常重要的，否则可能导致失真和模糊图像。为了找到正确的Mipmap级别，我们需要知道当前渲染纹理的大小与原始纹理的比例因子（即缩放因子）。

通常情况下，可以使用以下公式来计算当前纹理应该采用哪个Mipmap级别：

lod = log2(scale)
$$
lod = log_2{Scale}
\\ \\
Scale = max\left(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dx})^2}, \sqrt{(\frac{du}{dy})^2 + (\frac{du}{dy})^2}\right)
$$


其中，lod表示Mipmap级别，scale是当前纹理的大小与原始纹理的比例因子。该公式的基本思想是将比例因子转换为对数，然后向下取整得到最接近的Mipmap级别。

例如，如果当前纹理的大小为原始纹理的1/4，那么缩放因子就为0.25，此时可以使用上述公式计算出Mipmap级别为2。这意味着我们需要使用第二层Mipmap贴图进行渲染。

在一些实际应用中，当处理极小的纹理时，为了获得更好的效果，有时候会添加一些额外的Mipmap级别。此时，可以在计算公式中添加一个偏移量值来调整Mipmap级别，从而获得更精确的结果。



## 各项异性过滤

各向异性过滤（Anisotropic filtering，AF）是计算机图形学中一种用于提高纹理渲染质量的技术。该技术主要解决了常规纹理过滤技术中出现的失真、模糊和锯齿等问题。

在常规纹理过滤中，一个像素只能从最邻近的 Mipmap 级别中选择一个颜色进行采样。这意味着在倾斜或斜视的情况下，会发生大量的失真和锯齿。而各向异性过滤允许每个像素沿多个方向采样，以更准确地确定需要采样的纹理单元。

具体来说，各向异性过滤可以分为两个步骤：取样方向选择和纹理坐标计算。在取样方向选择阶段，通过使用卷积核函数，可以根据图像中相邻像素之间的角度和距离，计算出采样方向。然后，在纹理坐标计算阶段，使用所选的采样方向，计算出与各向异性比相关的纹理坐标，以获得最终的纹理颜色值。

各向异性过滤可以提高渲染质量，但也需要更多的计算资源。因此，当开启各向异性过滤时，需要权衡图形质量和性能需求，并考虑适当的优化策略，如降低采样率、使用Mipmap、硬件加速等。

各向异性过滤是一种用于提高纹理渲染质量的技术，它通过使用卷积核函数计算采样方向，并计算对应的纹理坐标，从而减少失真、模糊和锯齿等问题。



## 各项异性占内存多少（原图的3倍）

![image-20230922151727435](.\image-20230922151727435.png)

各向异性过滤（Anisotropic Filtering）是一种用于提高纹理渲染质量的技术，它可以消除常规纹理过滤中的失真和锯齿状边缘问题。与Mipmap不同，各向异性过滤不需要产生额外的纹理贴图，因此它所占用的内存空间相对较小。

各向异性过滤通常是由显卡硬件实现，因此不同硬件实现的内存消耗也会有所不同。另外，各向异性过滤的内存开销还取决于具体的使用情况和参数设置。

一般来说，各向异性过滤所需的内存大小主要有两个方面：卷积核函数和纹理坐标计算。卷积核函数通常是一个正方形的2D数组，大小通常为4x4或8x8。在纹理坐标计算中，需要存储每个像素沿多个方向的采样坐标。这些坐标通常需要使用浮点型数据类型来表示，并且需要根据纹理的大小和具体情况进行适当的优化。

总之，各向异性过滤所占用的内存空间相对较少，其内存消耗主要取决于硬件支持和具体实现。在实际应用中，需要根据场景、硬件性能和图像质量等因素进行权衡和调整。

## EWA纹理过滤算法

对比之前的纹理过滤算法，轴拉伸情况下采用各项异性过滤采样，整体等比缩小采用mipmap纹理过滤。现在有这种情况，如果纹理不是沿着轴拉伸的，比如倾斜的，那么这种时候采用各项异性和mipmap进行纹理采样都先得不合时宜。这时候就退出了EWA纹理过滤算法。

![image-20230922152433057](.\image-20230922152433057.png)

EWA（Elliptical Weighted Average）纹理过滤算法是一种基于椭圆加权平均的纹理过滤技术。该算法通过计算赋予每个像素椭圆形权值，对被贴在物体表面上的纹理进行过滤和渲染，从而提高渲染效果。

在EWA纹理过滤中，每个纹理像素都被视为一个椭圆形区域，它的大小和方向与采样所需纹理坐标和图像空间中相邻像素之间的角度和距离有关。具体来说，EWA算法可以分为以下几个步骤：

1. 计算出采样点到最近的四个纹理像素的距离和角度；
2. 将这些距离和角度转换为椭圆形权值，并计算每个像素的权重；
3. 对每个像素的颜色值进行加权平均，得到最终的纹理颜色值。

EWA算法可以有效地减少失真、锯齿状边缘和模糊等问题，并且可以提高纹理贴图的细节和清晰度。不过，由于需要计算复杂的椭圆形权值和加权平均，因此EWA算法通常需要更多的计算资源和内存开销。

总之，EWA纹理过滤算法是一种用于提高纹理渲染质量的技术，其主要思想是将每个纹理像素视为一个椭圆形区域，并计算出相应的椭圆形权值和加权平均，以消除失真、锯齿状边缘和模糊等问题。

## DX12的纹理过滤

### CD3DX12_STATIC_SAMPLER_DESC

CD3DX12_STATIC_SAMPLER_DESC是DirectX 12中一个用于描述静态采样器（Static Sampler）的结构体类。它提供了一种简化DirectX 12应用程序开发中采样器创建和配置的方式，使得开发者可以更加方便地定义和管理采样器。

该结构体类包含以下成员变量：

- shaderRegister：静态采样器绑定到着色器时的寄存器号。
- filter：纹理过滤器类型。可以是以下之一：
  - D3D12_FILTER_MIN_MAG_MIP_POINT：使用最近邻点采样，采样速度快，比线性采样快。**这种采样方法在放大或缩小时都会产生锐利的边缘和明显的像素化效果。因此，它通常用于特效，如像素艺术风格的渲染。**
  - D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR：使用距离目标像素最近的两个像素的加权平均值和与该平均值相邻的Mipmap级别的加权平均值进行线性插值采样。先进行一个点采样，然后再在两个邻近的mipmap之间做一个线性采样。**这种采样方法既可以用于放大也可以用于缩小，但可能会导致一些锐利的边缘出现模糊的效果，而不像D3D12_FILTER_MIN_MAG_MIP_POINT那么精确。**
  - D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT：使用距离目标像素最近的Mipmap级别的加权平均值以及该级别中两个最近的像素的线性插值采样。**使用点采样进行纹理缩小采样，使用放大进行线性差值采样，然后在通过点的方式进行mipmap采样。这种采样方式适用于纹理缩小，但在放大时效果较差。**
  - D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR：使用距离目标像素最近的Mipmap级别的加权平均值以及该级别中两个最近的像素和与它们相邻的Mipmap级别的加权平均值进行线性插值采样。**这种采样方式通常用于缩小，但在放大时效果也比D3D12_FILTER_MIN_MAG_MIP_POINT好一些。**
  - D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT：使用距离目标像素最近的两个Mipmap级别的加权平均值以及这些级别内最近的像素的线性插值采样。**使用线性差值缩小，使用点采样放大，再使用点采样在mipmap层级上进行采样，这种采样方式可用于放大和缩小，并且是默认的纹理过滤方法。**
  - D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR：使用距离目标像素最近的两个Mipmap级别的加权平均值以及该级别中两个最近的像素的线性插值采样和与该平均值相邻的Mipmap级别的加权平均值进行线性插值采样。**使用线性差值进行缩小，使用点采样进行放大，再使用线性差值进行mipmap层级上的一个采样。这种采样方式可用于放大和缩小，并且是默认的纹理过滤方法。。**
  - D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT：使用距离目标像素最近的Mipmap级别的加权平均值以及该级别中两个最近的像素的线性插值采样。**对纹理进行双线性过滤，缩小和放大，然后使用点采样来进行mipmap采样。这种采样方式在放大时效果很好，但在缩小时可能会失去细节。**
  - D3D12_FILTER_MIN_MAG_MIP_LINEAR：使用距离目标像素最近的Mipmap级别的加权平均值以及该级别中两个最近的像素和与它们相邻的Mipmap级别的加权平均值进行线性插值采样。**三线性过滤，它是对我们当前的纹理进行了一个双线性过滤，然后在邻近较高的的两个mipmap层级之间再进行一次线性差值过滤，这种采样方式用于放大和缩小。**
  - D3D12_FILTER_ANISOTROPIC：使用各向异性过滤进行采样。使用各项异性过滤来进行放大和缩小，然后进行mipmap采样。
- addressU/addressV/addressW：纹理寻址模式。可以是以下之一：
  - D3D12_TEXTURE_ADDRESS_MODE_WRAP：对于超出0到1的纹理坐标部分，会重复纹理图案。
  - D3D12_TEXTURE_ADDRESS_MODE_MIRROR：在纹理坐标超出0到1的范围时，镜像并重复纹理。
  - D3D12_TEXTURE_ADDRESS_MODE_CLAMP：将纹理坐标限制为0到1的范围。
  - D3D12_TEXTURE_ADDRESS_MODE_BORDER：当纹理坐标超出0到1的范围时，使用边界颜色。
  - D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE：在0到1范围内重复纹理，否则则镜像。
- mipLODBias：Mipmap级别偏移值。如果我们将该值设置为0，那么我们的mipmap采样层级是不会变的，固定1层。如果设置为2，mipmap层级就为3.
- maxAnisotropy：各向异性过滤的最大采样等级。
- comparisonFunc（比较函数）：用于深度或模板测试。可以是以下之一：
  - D3D12_COMPARISON_FUNC_NEVER：返回false。
  - D3D12_COMPARISON_FUNC_LESS：如果输入值小于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_EQUAL：如果输入值等于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_LESS_EQUAL：如果输入值小于或等于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_GREATER：如果输入值大于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_NOT_EQUAL：如果输入值不等于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_GREATER_EQUAL：如果输入值大于或等于参考值，则返回true，否则返回false。
  - D3D12_COMPARISON_FUNC_ALWAYS：返回true。
- borderColor（边界颜色）：用于处理超出纹理坐标范围的情况。可以是以下之一：
  - D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK：黑色透明。
  - D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK：黑色不透明。
  - D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE：白色不透明。
- minLOD（Mipmap级别取样范围最小值）：用于控制纹理采样时使用哪些Mipmap级别。默认值为0.0f。
- maxLOD（Mipmap级别取样范围最大值）：用于控制纹理采样时使用哪些Mipmap级别。默认值为D3D12_FLOAT32_MAX。
- shaderRegisterSpace（寄存器空间）：着色器寄存器的空间索引，默认值为0。
- shaderVisibility（着色器可见性）：用于指定静态采样器在哪个着色器阶段可见。可以是以下之一：
  - D3D12_SHADER_VISIBILITY_ALL：在所有着色器阶段都可见。
  - D3D12_SHADER_VISIBILITY_VERTEX：只在顶点着色器阶段可见。
  - D3D12_SHADER_VISIBILITY_HULL：只在镶嵌着色器阶段（外壳着色器hs）可见。
  - D3D12_SHADER_VISIBILITY_DOMAIN：只在域着色器阶段可见。
  - D3D12_SHADER_VISIBILITY_GEOMETRY：只在几何着色器阶段可见。
  - D3D12_SHADER_VISIBILITY_PIXEL：只在像素着色器阶段可见。

通过使用CD3DX12_STATIC_SAMPLER_DESC，开发者可以轻松创建和配置采样器，从而获得更高质量的渲染效果。在DirectX 12应用程序中，通常会在根签名（Root Signature）中定义并绑定静态采样器，以支持各种不同的纹理渲染需求。
