# 各向异性渲染

## 介绍

头发的渲染有很多方法，主要有分基于法线的（STRAND BASE）和基于多边形面片的（PolygonBase）。而头发的渲染其实也是各向异性的一种线像。我们会在以下章节介绍一下相关的技术基础，包括了：

- **各向异性v.s.各向同性**
- **Kajiya-Kay模型 （基于经验）**
- **Marschner's (R/RR/TRT) （基于物理）**
- **LUT Marschner's模型（基于物理，近似）**
- **Strand Based, Single Scattering & Multi Scattering模型（基于物理）**



- **基于法线**
- **基于多边形面片**

## **各向异性v.s.各向同性**

各向异性着色是在垂直于表面上的纹理或凹槽的方向上延伸反射。如果把各向异性渲染与更常见的各向同性渲染进行对比的话。各向同性渲染在所有方向上均匀地散射光，而各向异性头发在不同的方位角及跟据表面颗粒形状的纹理而改变，一般在拉丝钢，CD光盘，头发，等划痕表面产生垂直于纹理方向的高光。

![image-20230910193316037](.\image-20230910193316037.png)

这是因为在这些表面微观细看，我们会发现微观上是有一根一根的划痕的东西。

各向异性的BRDF有以下的: $f(\omega_o, \omega_i, \theta_i, \theta_o) \neq f(\omega_o - \omega_i, \theta_i, \theta_o)$

各向同性的BRDF有以下的:   $f(\omega_o, \omega_i, \theta_i, \theta_o) = f(\omega_o - \omega_i, \theta_i, \theta_o)$

## **Blinn-Phong光照模型**

Blinn-Phong光照模型是我们平常用的公式，这是一个各向同性光照模型，一般一个点的法线N是比较固定的，可以从vertex或normal map得到。光照公式如下：

$I_{s blinnPhong} = L_i * k_s (\vec{N} \cdot \vec{H})^n$ ，其中

- $I_s$ 是高光强度
- $L_i$ 是入射光强度
- $K_s$ 是高光反射率
- $\vec{N}$ 是法线方向
- $\vec{H}$是中线方向
- $n$ 是光滑度

使用Blinn-Phong光照，我们可以看到一个椭圆形的高光亮点，但是无法模拟各向异性的拉丝钢，头发等环状高光效果。

![image-20230910194041535](.\image-20230910194041535.png)

## 各向异性光照模型

![image-20230910194133214](.\image-20230910194133214.png)

各向异性光照表面微观细看，会发现有一根一根的划痕的东西。这个表面的一个点可能有多个法线。所以法线N不是唯一的，我们不能用N来判断表面方向。反而切线T是我们要关注的。各向异性光照是使用L及T来算光照的。

![image-20230910194205456](.\image-20230910194205456.png)

如之前的L是入射光方向，T是切线，我们可以用T和L的平面来确定唯一的一条于T和L公面的法线 $N_c$ 。光照可以如下公式得到：
$$
\vec{N_c} \cdot \vec{L} = \cos{\theta} = \sin{(\frac{\pi}{2} - \theta)} = \sqrt{1-\cos{^2(\frac{\pi}{2} - \theta)}} = \sqrt{1-(\vec{T} \cdot \vec{L})^2} 
$$


同一原因, 因为L只是一个符号，我们可以用H代入 L
$$
\vec{N_c} \cdot \vec{H} = \sqrt{1- (\vec{T} \cdot \vec{H})^2}
$$


现在我们确定了 $\vec{N_c} \cdot \vec{H}$，我们的各向异性光照是怎么呢。

如Blinn-Phong一样，我们只需要代入  $\vec{N_c} \cdot \vec{H}$
$$
I_{s anisotopoc} = L_i * k_s (\vec{N_c} \cdot \vec{H})^2
\\
= L_i * k_s * (\sqrt{1-(\vec{T} \cdot \vec{H})^2})^n
$$


![image-20230910195314263](.\image-20230910195314263.png)









## 各向异性数学原理

对于各项异性材质shader，下面这个效果图应该是我们最终需要的效果图，两边暗部，中间亮部

![image-20230910200546281](.\image-20230910200546281.png)





### 公式来源

![image-20230910200801939](.\image-20230910200801939.png)


$$
\sin{(T, H)}^{specularty} = \sqrt{1-dot(T, H)^2}
$$

### 公式推导

参数说明

- T 顶点切线
- L 光线
- N 顶点法线
- V 视角线
- H 光线和视角线的半程向量



首先，我们知道一个三角函数的平方关系
$$
\sin{^2 \alpha} + \cos{^2 \alpha} = 1
\\
\\ 然后
\\ 
\\
\sin{^2 \alpha} = 1 - \cos{^2 \alpha}
\\ \\ 开平方得到 \\ \\
\sin{\alpha} = \sqrt{1-\cos{^2 \alpha}}
$$
然后，这里 α 就是我们上面的图中的 切线T和半程向量H的夹角。带入点乘即可得到 $\sin{(T, H)}^{specularty} = \sqrt{1-dot(T, H)^2}$

![image-20230910204401239](.\image-20230910204401239.png)

该函数值在数学图像中的意义

cos α 的数学图像

![image-20230910203620739](.\image-20230910203620739.png)

cos α 开方后的数学图像在（下图紫色）

![image-20230910203555543](.\image-20230910203555543.png)

首先，$\cos{^2 \alpha}$ 的数学曲线长这样，很好理解，对吧，就是将cos α 的值平方后，负数取正，然后曲线聚拢（为啥会聚拢，很好理解，0-1的小数，开方就是会得到比原本更小的数，多揣摩）

![image-20230910203206534](.\image-20230910203206534.png)

然后 $1-\cos{^2 \alpha}$ ，得到的图像如下，蓝色的图像，很容易看出来，就是将原本的 $\cos{^2 \alpha}$ 曲线进行翻转

![image-20230910203924692](.\image-20230910203924692.png)



然后我们最后对蓝色曲线开根号，即可得到，$\sin{\alpha} = \sqrt{1-\cos{^2 \alpha}}$， 即下面绿色的曲线，让边缘更加锐利

![image-20230910204232723](.\image-20230910204232723.png)



然后思考shader原理，或者说，这个函数带入shader是什么效果，这里我们先不考虑带入切线进行思考，而是用法线进行模拟。

我们知道，法线和光线的点乘，得到的就是一个兰伯特材质效果，大概长这样, cos θ，值的范围是[-1, 1]

![image-20230910204855991](.\image-20230910204855991.png)

然后我们对cos θ 进行平方。得到的值的范围就是[1, 1]，更准确的就是 [1, 0],  [0, 1]，表现在shader中就是如下这种效果，

![image-20230910222731141](.\image-20230910222731141.png)

然后，用1减去这个值，就相当于给shader取反，原本暗的地方变亮，亮的地方变暗，就是如下效果

![image-20230910223007646](.\image-20230910223007646.png)

开根号，就是将这个效果范围扩大了点。

然后至此，我们就大致构建出我们想要的渲染模型，但是我们发现，他的方向是垂直的，而我们想要的最终效果是水平的，这是因为我们上面这些模拟都是在法线点乘的基础上进行的，而想要水平，我们只需要将法线改为顶点切线，就能得到水平方向的效果

![image-20230910223456287](.\image-20230910223456287.png)

## TBN

从上面的图我们可以看到，切线T是沿着我们的发丝走的，法线N是垂直发丝的。这里我需要引入一个新的概念，TBN。

TBN中T代表切线，N代表法线，而B，B是我们自定义的一个向量。

这里我们回顾一下向量叉乘，；两个向量叉乘的结果是得到一个垂直于这两个向量所在平面的向量。

在TBN中，我们T切线是不清楚的，B也是不清楚的，我们只知道法线N。那么我们之前知道，B是我们自定义的一个向量，那么我们可以定义这个B为我们的x轴正方向 （1， 0， 0），当然你也可以定义其他坐标轴的正方向作为B，定义好B以后，将B和N进行叉乘即可得到我们的T，得到T之后，带入之前的公式即可得到我想要的shader计算值。







